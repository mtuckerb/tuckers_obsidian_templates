---
modified:
  - 2025-08-26T16:43:24-04:00
  - 2025-08-25T18:52:12-04:00
date created: Monday, August 25th 2025, 10:52:43 pm
date modified: Tuesday, August 26th 2025, 8:43:55 pm
---
<%*
const { exec } = require("child_process");
  let courseName = await tp.system.prompt("Course Name (e.g. PSI-101 - Intro to Psych)")
  let courseSeason = await tp.system.suggester(["Fall","Winter","Spring","Summer"],["Fall","Winter","Spring","Summer"], "Season")
  let courseYear = await tp.system.prompt("Year")
  let courseId = courseName.split(' - ')[0]
  //await tp.file.rename(courseName);
  await tp.file.move(`/${courseYear}/${courseSeason}/${courseName}/${courseName}`)
  try {await app.vault.createFolder(`${courseYear}/${courseSeason}/${courseName}/Attachments`)} catch (e) {}
%>---
course_id: <%courseId%>
course_season: <% courseSeason %>
contentType: Course
course_year: <%courseYear%>
created: <% tp.date.now("YYYY-MM-DD[T]hh:mm:SSSSZZ") %>
tags: 
  - <% courseId %>
  - USM/<%courseYear%>/<%courseSeason%>/<% courseId %>/
  - course_home
  - education
  - University_of_Southern_Maine
banner: 
cssclasses: 
 - whiteRed
 - whiteRed-rounded
 - table-wide
course_homepage:
course_britespace:
contact_name:
contact_phone:
contact_email:
course_time:
course_dow:
- 
course_location:

icon: LiGraduationCap
iconColor: orange
aliases:
title: <%courseName%>
texts:
---
**Course Homepage:**  `VIEW[{course_homepage}][link]` 
**Britespace URL:** `VIEW[{course_britespace}][link]` 
**Professor**: `VIEW[{contact_name}][text]`
**Prof Phone:** `VIEW[{contact_phone}][link]`
**Prof Email**: `VIEW[{contact_email}][link]`
**Time**: `VIEW[{course_time}][text]` 
**Days of Week**: `INPUT[inlineList:course_dow]`
**Location**:  `VIEW[{course_location}][text]`  
**Texts**:
```meta-bind-js-view
{texts} as texts
---
const availableTexts = app.vault.getFiles().filter(file => file.extension == 'pdf').map(f => f?.name)
const escapeRegex = /[,"'(),`]/g;
options = availableTexts.map(t => `option([[${t.replace(escapeRegex,`\$1`)}]], ${t.replace(escapeRegex,`\$1`)})` )
const str = `\`INPUT[inlineListSuggester(${options.join(", ")}):texts]\``
return engine.markdown.create(str)
```
---
```dataviewjs
 function deduplicateFirstTwoColumns(arr) {
	const seen = new Set();
	return arr.filter(entry => {
		const key = JSON.stringify([entry[0], entry[1]]);
		return !seen.has(key) && seen.add(key);
	});
}
const processDueDates = async ( dv, courseId, cutOff = []) => {
  const startDate =
    cutOff.length > 0
      ? moment(cutOff[0]).format("YYYY-MM-DD")
      : moment().subtract(1, "day").format("YYYY-MM-DD")
  const endDate = moment(cutOff[1]).format("YYYY-MM-DD")
  const pages = await dv.pages(`${courseId}`)
    .filter((p) => p.file.name !== courseId && p.file.ext == "md")

  let allEntries = []

  for (const page of pages.values) {
    if (!page?.file?.path) { return }
      const content = await app.vault.cachedRead(app.vault.getFileByPath(page.file?.path))
	const regex = /# Due Dates([\s\S]*?)(?=\n#|$)/
	const matches = content?.match(regex)
	if (matches) {
	  const tableData = matches[1].trim()
	  const lines = tableData.split("\n").slice(1)
	  for (const line of lines) {
		let formattedDueDate
		const columns = line
		  .split("|")
		  .map((c) => c.trim())
		  .filter((c) => c)
		let [dueDate, assignment] = columns
		if (!Date.parse(dueDate) || assignment?.match(/âœ…/)) {
		  continue
		}
		assignment = assignment?.match(/[A-Z]{3}-[0-9]{3}/)
		  ? assignment
		  : `#${page.course_id} - ${assignment}`
		console.log(`Due: ${dueDate}, Assignment ${assignment}`)
		console.log(cutOff, startDate, endDate)
		if (
		  moment(dueDate).isBetween(startDate, endDate) ||
		  cutOff.length == 0
		) {
		  const uniqueRow = !allEntries.some(
			(e) =>
			  e[0].match(moment(dueDate)?.format("YYYY-MM-DD")) &&
			  e[1] == assignment
		  )
		  if (assignment && uniqueRow) {
			if (moment(dueDate)?.isBefore(startDate)) {
			  continue
			} else if (moment(dueDate).isAfter(moment().subtract(1, "w"))) {
			  formattedDueDate = `<span class="due one_week">${moment(
				dueDate
			  )?.format("YYYY-MM-DD ddd")}</span>`
			} else if (moment(dueDate).isAfter(moment().subtract(2, "w"))) {
			  formattedDueDate = `<span class="due two_weeks">${moment(
				dueDate
			  )?.format("YYYY-MM-DD ddd")}</span>`
			} else {
			  formattedDueDate = moment(dueDate)?.format("YYYY-MM-DD ddd")
			}
			allEntries.push([
			  dueDate,
			  formattedDueDate,
			  assignment,
			  `[[${page?.file?.path}|${page?.file?.name}]]`,
			])
		  }
		}
	  }
	}
  }

	  const sortedRows = deduplicateFirstTwoColumns(allEntries
	     .sort((a, b) => moment(a[0]).valueOf() - moment(b[0]).valueOf() ) 
	     .map((a) => [a[1], a[2], a[3]])
	  )
	   const table = dv.markdownTable( ["Due Date", "Task Description", "File"], sortedRows )
	      dv.el("table", table)
	}
	processDueDates(dv,'#<%courseId%>')
```

```dataviewjs
async function processCourseVocabulary(dv, courseName){
    
    try {
        
        const pages = dv.pages(courseName)
            .filter(p => p.file.ext === "md")
            .map(p => ({
                name: p.file.name,
                path: p.file.path
            }));

        // Process each page and extract vocabulary
        dv.header(1, "All Course Vocabulary");
        
        for (const page of pages) {
            if (!page.path) continue;
            
            try {   
                const file    = await dv.app.vault.getFileByPath(page.path);
                const content = await dv.app.vault.read(file);
                
                // Extract vocabulary using regex
                const vocabRegex = /^#+ Vocabulary.*\n((?:.*?\n)*?)(?=^\s*#\s|$)/m;
                const vocabMatches = content?.match(vocabRegex);

                if (vocabMatches) {
                    const vocabData   = vocabMatches[1].trim();
                    const cleanedVocab = vocabData
                        .replace(/\[\[.*?\]\]/g, '')  // Remove wikilinks
                        .trim()
                        .split('- ')
                        .filter(Boolean)
//                        .filter(b => (b !== "" && b !== null && b !== undefined)); 

                    if (cleanedVocab.length > 0) {
                        dv.header(3, `[[${page.name}]]`);
                        dv.list(cleanedVocab);
                    }
                }

            } catch (e) {
                console.log(`Error processing ${page.path}:`, e);
                continue;
            }
        }

    } catch (error) {
        console.error("Error in Vocabulary Processing:", error);
    }
}
processCourseVocabulary(dv, '"<% courseId %>"')
```

```folder-index-content
```